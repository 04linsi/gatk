package org.broadinstitute.hellbender.tools.walkers.vqsr;

import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.argparser.ExperimentalFeature;
import org.broadinstitute.hellbender.cmdline.CommandLineProgram;
import org.broadinstitute.hellbender.cmdline.programgroups.ShortVariantDiscoveryProgramGroup;
import org.broadinstitute.hellbender.utils.io.Resource;
import org.broadinstitute.hellbender.utils.python.PythonScriptExecutor;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Train a Convolutional Neural Network (CNN) for filtering variants.
 * This tool expects training data generated by {@link CNNVariantWriteTensors}.
 *
 *
 * <h3>Inputs</h3>
 * <ul>
 *      <li>data-dir The training data created by {@link CNNVariantWriteTensors}.</li>
 *      <li>The tensor-name argument determines what types of tensors the model will expect.
 *      Set it to "reference" for 1D tensors or "read_tensor" for 2D tensors.</li>
 * </ul>
 *
 * <h3>Outputs</h3>
 * <ul>
 * <li>output-dir The model weights file and semantic configuration json are saved here.
 *  This default to the current working directory.</li>
 * <li>model-name The name for your model.</li>
 * </ul>
 *
 * <h3>Usage example</h3>
 *
 * <h4>Train a 1D CNN on Reference Tensors</h4>
 * <pre>
 * gatk CNNVariantTrain \
 *   -tensor-name reference \
 *   -data-dir my_tensor_folder \
 *   -model-name my_1d_model
 * </pre>
 *
 * <h4>Train a 2D CNN on Read Tensors</h4>
 * <pre>
 * gatk CNNVariantTrain \
 *   -data-dir my_tensor_folder \
 *   -tensor-name read_tensor \
 *   -model-name my_2d_model
 * </pre>
 *
 */
@CommandLineProgramProperties(
        summary = "Train a CNN model for filtering variants",
        oneLineSummary = "Train a CNN model for filtering variants",
        programGroup = ShortVariantDiscoveryProgramGroup.class
)

@ExperimentalFeature
public class CNNVariantTrain extends CommandLineProgram {

    @Argument(fullName = "data-dir", shortName = "dd", doc = "Directory of training tensors, created if write-tensors is true, otherwise read.", optional = true)
    private String dataDir = "";

    @Argument(fullName = "tensor-name", shortName = "tn", doc = "Name of the tensors to generate, reference for 1D reference tensors and read_tensor for 2D tensors.", optional = true)
    private String tensorName = "reference";

    @Argument(fullName = "annotation-set", shortName = "as", doc = "Which set of annotations to use.", optional = true)
    private String annotationSet = "best_practices";

    @Argument(fullName = "output-dir", shortName = "od", doc = "Directory where models and plots will be saved.", optional = true)
    private String outputDir = "./";

    @Argument(fullName = "model-name", shortName = "mn", doc = "Name of the model to be trained.", optional = true)
    private String modelName = "variant_filter_model";

    @Argument(fullName = "epochs", shortName = "e", doc = "Maximum number of training epochs.", optional = true, minValue = 0)
    private int epochs = 10;

    // Start the Python executor. This does not actually start the Python process, but fails if python can't be located
    final PythonScriptExecutor pythonExecutor = new PythonScriptExecutor(true);


    @Override
    protected void onStartup() {
        PythonScriptExecutor.checkPythonEnvironmentForPackage("vqsr_cnn");

    }

    @Override
    protected Object doWork() {
        final Resource pythonScriptResource = new Resource("training.py", VariantTranchesPython.class);
        List<String> arguments = new ArrayList<>(Arrays.asList(
                "--tensor_name", tensorName,
                "--annotation_set", annotationSet,
                "--epochs", Integer.toString(epochs),
                "--data_dir", dataDir,
                "--output_dir", outputDir,
                "--id", modelName));

        if (tensorName.equals("reference")) {
            arguments.addAll(Arrays.asList("--mode", "train_on_reference_tensors_and_annotations"));
        } else if (tensorName.equals("read_tensor")) {
            arguments.addAll(Arrays.asList("--mode", "train_on_read_tensors_and_annotations"));
        }

        logger.info("Args are:"+ Arrays.toString(arguments.toArray()));
        final boolean pythonReturnCode = pythonExecutor.executeScript(
                pythonScriptResource,
                null,
                arguments
        );
        return pythonReturnCode;
    }

}
