package org.broadinstitute.hellbender.tools.walkers.vqsr;

import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.argparser.ExperimentalFeature;
import org.broadinstitute.barclay.argparser.Hidden;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hellbender.cmdline.CommandLineProgram;
import org.broadinstitute.hellbender.exceptions.GATKException;
import org.broadinstitute.hellbender.utils.io.Resource;
import org.broadinstitute.hellbender.utils.python.PythonScriptExecutor;
import picard.cmdline.programgroups.VariantEvaluationProgramGroup;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Train a Convolutional Neural Network (CNN) for filtering variants.
 * This tool expects training data generated by {@link CNNVariantWriteTensors}.
 *
 *
 * <h3>Inputs</h3>
 * <ul>
 *      <li>data-dir The training data created by {@link CNNVariantWriteTensors}.</li>
 *      <li>The tensor-name argument determines what types of tensors the model will expect.
 *      Set it to "reference" for 1D tensors or "read_tensor" for 2D tensors.</li>
 * </ul>
 *
 * <h3>Outputs</h3>
 * <ul>
 * <li>output-dir The model weights file and semantic configuration json are saved here.
 *  This default to the current working directory.</li>
 * <li>model-name The name for your model.</li>
 * </ul>
 *
 * <h3>Usage example</h3>
 *
 * <h4>Train a 1D CNN on Reference Tensors</h4>
 * <pre>
 * gatk CNNVariantTrain \
 *   -tensor-name reference \
 *   -data-dir my_tensor_folder \
 *   -model-name my_1d_model
 * </pre>
 *
 * <h4>Train a 2D CNN on Read Tensors</h4>
 * <pre>
 * gatk CNNVariantTrain \
 *   -data-dir my_tensor_folder \
 *   -tensor-name read_tensor \
 *   -model-name my_2d_model
 * </pre>
 *
 */
@CommandLineProgramProperties(
        summary = "Train a CNN model for filtering variants",
        oneLineSummary = "Train a CNN model for filtering variants",
        programGroup = VariantEvaluationProgramGroup.class
)
@DocumentedFeature
@ExperimentalFeature
public class CNNVariantTrain extends CommandLineProgram {

    @Argument(fullName = "input-data-dir", shortName = "input-data-dir", doc = "Directory of training tensors, created if write-tensors is true, otherwise read.")
    private String dataDir;

    @Argument(fullName = "output-dir", shortName = "output-dir", doc = "Directory where models and plots will be saved.")
    private String outputDir;

    @Argument(fullName = "tensor-name", shortName = "tensor-name", doc = "Name of the tensors to generate, reference for 1D reference tensors and read_tensor for 2D tensors.", optional = true)
    private TensorMapEnum tensorMap = TensorMapEnum.reference;

    @Hidden
    @Argument(fullName = "annotation-set", shortName = "annotation-set", doc = "Which set of annotations to use.", optional = true)
    private String annotationSet = "best_practices";

    @Argument(fullName = "model-name", shortName = "model-name", doc = "Name of the model to be trained.", optional = true)
    private String modelName = "variant_filter_model";

    @Argument(fullName = "epochs", shortName = "epochs", doc = "Maximum number of training epochs.", optional = true, minValue = 0)
    private int epochs = 10;

    // Start the Python executor. This does not actually start the Python process, but fails if python can't be located
    final PythonScriptExecutor pythonExecutor = new PythonScriptExecutor(true);


    @Override
    protected void onStartup() {
        PythonScriptExecutor.checkPythonEnvironmentForPackage("vqsr_cnn");
    }

    @Override
    protected Object doWork() {
        final Resource pythonScriptResource = new Resource("training.py", VariantTranchesFromInfoKey.class);
        List<String> arguments = new ArrayList<>(Arrays.asList(
                "--tensor_name", tensorMap.name(),
                "--annotation_set", annotationSet,
                "--epochs", Integer.toString(epochs),
                "--data_dir", dataDir,
                "--output_dir", outputDir,
                "--id", modelName));

        if (tensorMap == TensorMapEnum.reference) {
            arguments.addAll(Arrays.asList("--mode", "train_on_reference_tensors_and_annotations"));
        } else if (tensorMap == TensorMapEnum.read_tensor) {
            arguments.addAll(Arrays.asList("--mode", "train_on_read_tensors_and_annotations"));
        } else {
            throw new GATKException("Unknown tensor mapping mode:"+tensorMap.name());
        }

        logger.info("Args are:"+ Arrays.toString(arguments.toArray()));
        final boolean pythonReturnCode = pythonExecutor.executeScript(
                pythonScriptResource,
                null,
                arguments
        );
        return pythonReturnCode;
    }

}
